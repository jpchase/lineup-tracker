import * as actions from '@app/actions/game';
import { Game, Games } from '@app/models/game';
import { firebaseRef } from '@app/firebase';
// import { Query, QuerySnapshot } from '@firebase/firestore-types';
/// <reference path="mock-cloud-firestore.d.ts" />
import * as MockFirebase from 'mock-cloud-firestore';
import * as test_data from '../helpers/test_data';

jest.mock('@app/firebase');

const PUBLIC_GAME_ID = 'pg1';

function getPublicGameData() {
    return {
        teamId: test_data.getPublicTeam().id,
        date: new Date(2016, 1, 10),
        opponent: 'Public Opponent'
    }
};

function getPublicGame(): Game {
    return { id: PUBLIC_GAME_ID, ...getPublicGameData() }
};

function getStoredGameData() {
    return {
        teamId: test_data.getStoredTeam().id,
        date: new Date(2016, 1, 10),
        opponent: 'Stored Game Opponent'
    }
};

const STORED_GAME_ID = 'sg1';
function getStoredGame(): Game {
    return { id: STORED_GAME_ID, ...getStoredGameData() }
};

const fixtureData = {
    __collection__: {
        games: {
            __doc__: {
                [STORED_GAME_ID]: {
                  ...getStoredGameData(),
                    owner_uid: test_data.TEST_USER_ID,
                },
                [PUBLIC_GAME_ID]: {
                    ...getPublicGameData(),
                    public: true,
                },
            }
        }
    }
};

function mockGetState(games: Game[], options?: test_data.MockAuthStateOptions) {
  return jest.fn(() => {
    // const teamData = buildTeams(teams);

    return {
      auth: test_data.getMockAuthState(options),
      games
      // team: {
      //   teamId: currentTeam ? currentTeam.id : undefined,
      //   teamName: currentTeam ? currentTeam.name : undefined,
      //   teams: teamData
      // }
    };
  });
}


describe('Game actions', () => {
  const mockFirebase = new MockFirebase(fixtureData);

  beforeEach(() => {
    jest.resetAllMocks();

    firebaseRef.firestore.mockImplementation(() => {
      return mockFirebase.firestore();
    });
  });

  describe('getGames', () => {
    it('should return a function to dispatch the getGames action', () => {
      expect( typeof actions.getGames() ).toBe('function');
    });

    it('should do nothing if team id is missing', () => {
      const dispatchMock = jest.fn();
      const getStateMock = jest.fn();

      actions.getGames()(dispatchMock, getStateMock, undefined);

      expect(firebaseRef.firestore).not.toHaveBeenCalled();

      expect(dispatchMock).not.toBeCalled();
    });

    it('should dispatch an action with owned games returned from storage', async () => {
        const dispatchMock = jest.fn();
        const getStateMock = mockGetState([], { signedIn: true, userId: test_data.TEST_USER_ID })

        actions.getGames(test_data.getStoredTeam().id)(dispatchMock, getStateMock, undefined);

        // Waits for promises to resolve.
        await Promise.resolve();

        expect(dispatchMock).toBeCalledWith(expect.objectContaining({
            type: actions.GET_GAMES,
            games: buildGames([getStoredGame()]),
        }));
    });

    it('should dispatch an action with public games when not signed in', async () => {
        const dispatchMock = jest.fn();
        const getStateMock = mockGetState([], { signedIn: false })

        actions.getGames(test_data.getPublicTeam().id)(dispatchMock, getStateMock, undefined);

        // Waits for promises to resolve.
        await Promise.resolve();

        expect(dispatchMock).toBeCalledWith(expect.objectContaining({
            type: actions.GET_GAMES,
            games: buildGames([getPublicGame()]),
        }));
    });

    it('should not dispatch an action when storage access fails', async () => {
      const dispatchMock = jest.fn();
      const getStateMock = jest.fn();

      firebaseRef.firestore.mockImplementationOnce(() => { throw new Error('Storage failed with some error'); });

      expect(() => {
        actions.getGames(test_data.getStoredTeam().id)(dispatchMock, getStateMock, undefined);
      }).toThrow();

      // Waits for promises to resolve.
      await Promise.resolve();

      expect(dispatchMock).not.toBeCalled();
    });

  }); // describe('getGames')

/*
describe('addNewGame', () => {
  const storedPlayer: Player = {
      id: 'sp1', name: 'Stored player 1', uniformNumber: 5, positions: ['CB'], status: 'OFF'
  };
  const newPlayer: Player = {
      id: 'np1', name: 'New player 1', uniformNumber: 1, positions: ['CB'], status: 'OFF'
  };

  it('should return a function to dispatch the action', () => {
    expect(typeof actions.addNewPlayer()).toBe('function');
  });

  it('should do nothing if new player is missing', () => {
    const dispatchMock = jest.fn();
    const getStateMock = jest.fn();

    actions.addNewPlayer()(dispatchMock, getStateMock, undefined);

    expect(getStateMock).not.toBeCalled();

    expect(dispatchMock).not.toBeCalled();
  });

  it('should dispatch an action to add a new player that is unique', () => {
    const dispatchMock = jest.fn();
    const getStateMock = jest.fn(() => {
      const playerData: Roster = {};
      playerData[storedPlayer.id] = storedPlayer;
      return {
        team: {
          roster: playerData
        }
      };
    });

    actions.addNewPlayer(newPlayer)(dispatchMock, getStateMock, undefined);

    expect(getStateMock).toBeCalled();

    expect(dispatchMock).toBeCalledWith(expect.any(Function));
  });

  it('should do nothing with a new player that is not unique', () => {
    const dispatchMock = jest.fn();
    const getStateMock = jest.fn(() => {
      const playerData: Roster = {};
      playerData[newPlayer.id] = newPlayer;
      return {
        team: {
          roster: playerData
        }
      };
    });

    actions.addNewPlayer(newPlayer)(dispatchMock, getStateMock, undefined);

    expect(getStateMock).toBeCalled();

    expect(dispatchMock).not.toBeCalled();
  });
});  // describe('addNewGame')
*/
/*
describe('saveGame', () => {
    const storedPlayer: Player = {
        id: 'sp1', name: 'Stored player 1', uniformNumber: 5, positions: ['CB'], status: 'OFF'
    };
    const newPlayer: Player = {
        id: 'np1', name: 'New player 1', uniformNumber: 1, positions: ['CB'], status: 'OFF'
    };

    beforeEach(() => {
    });

    it('should return a function to dispatch the action', () => {
        expect(typeof actions.savePlayer()).toBe('function');
    });

    it('should dispatch an action to add player', async () => {
        const dispatchMock = jest.fn();
        const getStateMock = jest.fn(() => {
            const playerData: Roster = {};
            playerData[storedPlayer.id] = storedPlayer;
            return {
                team: {
                    roster: playerData
                }
            };
        });

        actions.savePlayer(newPlayer)(dispatchMock, getStateMock, undefined);

        // Waits for promises to resolve.
        await Promise.resolve();

        expect(dispatchMock).toBeCalledWith(expect.any(Function));
    });

    it('should not dispatch an action when set() fails', async () => {
        const dispatchMock = jest.fn();
        const getStateMock = jest.fn(() => {
            const playerData: Roster = {};
            playerData[storedPlayer.id] = storedPlayer;
            return {
                team: {
                    roster: playerData
                }
            };
        });

        actions.savePlayer(newPlayer)(dispatchMock, getStateMock, undefined);

        // Waits for promises to resolve.
        await Promise.resolve();

        // TODO: Remove when data saving logic implemented.
        expect(dispatchMock).toBeCalledWith(expect.any(Function));
    });
}); // describe('saveGame')
*/
/*
describe('addPlayer', () => {
  const newPlayer: Player = {
      id: 'np1', name: 'New player 1', uniformNumber: 1, positions: ['CB'], status: 'OFF'
  };

  it('should return a function to dispatch the addPlayer action', () => {
    expect(typeof actions.addPlayer()).toBe('function');
  });

  it('should dispatch an action to add the player', () => {
    const dispatchMock = jest.fn();
    const getStateMock = jest.fn();

    actions.addPlayer(newPlayer)(dispatchMock, getStateMock, undefined);

    expect(dispatchMock).toBeCalledWith(expect.objectContaining({
      type: actions.ADD_PLAYER,
      player: newPlayer,
    }));
  });

}); describe('addGame')
*/
}); // describe('Game actions')
